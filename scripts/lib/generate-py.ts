/**
 * Generate Python Pydantic v2 models from the OXA JSON Schema.
 *
 * This module generates Pydantic models with:
 *
 * - Discriminated unions using Literal types and Annotated with discriminator
 * - Full type hints for all properties
 * - Docstrings from schema descriptions
 * - Proper handling of optional vs required fields
 */

import { execSync } from "child_process";
import { readFileSync, writeFileSync } from "fs";
import { join } from "path";

import { loadMergedSchema } from "./schema.js";
import { getVersion } from "./version.js";

const PACKAGE_DIR = join(import.meta.dirname, "../../packages/oxa-types-py");

const OUTPUT_PATH = join(PACKAGE_DIR, "src/oxa_types/__init__.py");

const PYPROJECT_PATH = join(PACKAGE_DIR, "pyproject.toml");

interface SchemaProperty {
  type?: string;
  const?: string;
  description?: string;
  items?: { $ref?: string; type?: string };
  $ref?: string;
  minimum?: number;
  maximum?: number;
  additionalProperties?: boolean;
}

interface SchemaDefinition {
  title: string;
  description?: string;
  type?: string;
  anyOf?: Array<{ $ref: string }>;
  properties?: Record<string, SchemaProperty>;
  required?: string[];
}

export async function generatePy(): Promise<void> {
  // Sync version from root package.json to pyproject.toml
  const version = getVersion();
  const pyprojectContent = readFileSync(PYPROJECT_PATH, "utf-8");
  const versionMatch = pyprojectContent.match(/^version = "(.+)"$/m);
  if (versionMatch && versionMatch[1] !== version) {
    const updatedContent = pyprojectContent.replace(
      /^version = ".+"$/m,
      `version = "${version}"`,
    );
    writeFileSync(PYPROJECT_PATH, updatedContent);
    console.log(`Synced version to ${version} in ${PYPROJECT_PATH}`);
  }

  const schema = loadMergedSchema();
  const definitions = schema.definitions as Record<string, SchemaDefinition>;

  const lines: string[] = [
    '"""',
    "Pydantic models generated from the OXA JSON Schema.",
    "",
    "Do not edit this file directly. Instead, edit the YAML schema files",
    "in the schema/ directory and run `pnpm codegen py`.",
    '"""',
    "",
    "from __future__ import annotations",
    "",
    "from typing import Annotated, Any, Literal, Union",
    "",
    "from pydantic import BaseModel, ConfigDict, Field",
    "",
  ];

  // Collect union types for forward references
  const unionTypes: Map<string, string[]> = new Map();
  for (const [name, def] of Object.entries(definitions)) {
    if (def.anyOf) {
      const members =
        def.anyOf.map((item) => {
          const ref = item.$ref;
          return ref?.replace("#/definitions/", "") || "object";
        }) || [];
      unionTypes.set(name, members);
    }
  }

  // Generate model classes first (non-union types)
  for (const [name, def] of Object.entries(definitions)) {
    if (!def.anyOf && def.type === "object") {
      lines.push(...generateModel(name, def, unionTypes));
      lines.push("");
      lines.push("");
    }
  }

  // Generate union type aliases with discriminator
  for (const [name, def] of Object.entries(definitions)) {
    if (def.anyOf) {
      lines.push(...generateUnion(name, def));
      lines.push("");
      lines.push("");
    }
  }

  // Add model rebuild calls to resolve forward references
  lines.push("# Rebuild models to resolve forward references");
  for (const [name, def] of Object.entries(definitions)) {
    if (!def.anyOf && def.type === "object") {
      lines.push(`${name}.model_rebuild()`);
    }
  }
  lines.push("");

  // Generate __all__ export list
  const exportNames = Object.keys(definitions);
  lines.push("");
  lines.push("__all__ = [");
  for (const name of exportNames) {
    lines.push(`    "${name}",`);
  }
  lines.push("]");
  lines.push("");

  const code = lines.join("\n");
  writeFileSync(OUTPUT_PATH, code);

  // Format with ruff (skip if uv is not available)
  try {
    execSync(`uv run --project ${PACKAGE_DIR} ruff format ${OUTPUT_PATH}`, {
      stdio: "inherit",
    });
  } catch {
    console.warn("Warning: Could not format with ruff (is uv installed?)");
  }

  console.log(`Generated ${OUTPUT_PATH}`);
}

function generateModel(
  name: string,
  def: SchemaDefinition,
  unionTypes: Map<string, string[]>,
): string[] {
  const lines: string[] = [];

  lines.push(`class ${name}(BaseModel):`);

  // Add docstring
  if (def.description) {
    lines.push(`    """${def.description}"""`);
    lines.push("");
  }

  // Add model config for strict mode
  lines.push("    model_config = ConfigDict(strict=True)");
  lines.push("");

  const required = new Set(def.required || []);

  for (const [propName, prop] of Object.entries(def.properties || {})) {
    const pyType = getPythonType(prop, unionTypes);
    const isRequired = required.has(propName);

    // Build the field definition
    let fieldDef: string;
    if (prop.const) {
      // Const fields are Literal types with default values
      fieldDef = `    ${propName}: ${pyType} = "${prop.const}"`;
    } else if (isRequired) {
      if (prop.description) {
        fieldDef = `    ${propName}: ${pyType} = Field(description="${escapeString(prop.description)}")`;
      } else {
        fieldDef = `    ${propName}: ${pyType}`;
      }
    } else {
      if (prop.description) {
        fieldDef = `    ${propName}: ${pyType} | None = Field(default=None, description="${escapeString(prop.description)}")`;
      } else {
        fieldDef = `    ${propName}: ${pyType} | None = None`;
      }
    }

    lines.push(fieldDef);
  }

  // If no properties, add pass
  if (!def.properties || Object.keys(def.properties).length === 0) {
    lines.push("    pass");
  }

  return lines;
}

function generateUnion(name: string, def: SchemaDefinition): string[] {
  const lines: string[] = [];

  // Add docstring as comment
  if (def.description) {
    lines.push(`# ${def.description}`);
  }

  const members =
    def.anyOf?.map((item) => {
      const ref = item.$ref;
      return ref?.replace("#/definitions/", "") || "object";
    }) || [];

  // Use Annotated with Field discriminator for Pydantic v2
  const unionMembers = members.join(", ");
  lines.push(
    `${name} = Annotated[Union[${unionMembers}], Field(discriminator="type")]`,
  );

  return lines;
}

function getPythonType(
  prop: SchemaProperty,
  unionTypes: Map<string, string[]>,
): string {
  // Handle const values (type discriminator)
  if (prop.const) {
    return `Literal["${prop.const}"]`;
  }

  // Handle $ref
  if (prop.$ref) {
    const typeName = prop.$ref.replace("#/definitions/", "");
    // Use quoted string for forward references if it's a union type
    if (unionTypes.has(typeName)) {
      return `"${typeName}"`;
    }
    return `"${typeName}"`;
  }

  // Handle arrays
  if (prop.type === "array" && prop.items) {
    if (prop.items.$ref) {
      const itemType = prop.items.$ref.replace("#/definitions/", "");
      // Use quoted string for forward references
      return `list["${itemType}"]`;
    }
    if (prop.items.type === "string") {
      return "list[str]";
    }
    return "list[Any]";
  }

  // Handle basic types
  switch (prop.type) {
    case "string":
      return "str";
    case "integer":
      return "int";
    case "number":
      return "float";
    case "boolean":
      return "bool";
    case "object":
      if (prop.additionalProperties) {
        return "dict[str, Any]";
      }
      return "dict[str, Any]";
    default:
      return "Any";
  }
}

function escapeString(s: string): string {
  return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}
