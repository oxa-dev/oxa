/**
 * Generate TypeScript types from the OXA JSON Schema.
 *
 * This module uses a custom generator rather than existing libraries like
 * `json-schema-to-typescript` or `quicktype` for the following reasons:
 *
 * - `json-schema-to-typescript` fails on schemas with recursive `$ref`
 *   patterns (e.g., Strong → Inline → Strong), throwing "Refs should have
 *   been resolved" errors during parsing.
 *
 * - `quicktype` merges `anyOf` schemas into a single interface with all
 *   properties optional, rather than generating proper TypeScript
 *   discriminated unions (e.g., `type Block = Heading | Paragraph`).
 *
 * Our custom generator produces clean discriminated union types that:
 *
 * - Preserve the `type` discriminator as a literal type
 * - Generate proper union types for `anyOf` schemas
 * - Include JSDoc comments from schema descriptions
 * - Handle all property types (primitives, arrays, refs) correctly
 */

import { writeFileSync } from "fs";
import { join } from "path";

import prettier from "prettier";

import { loadMergedSchema } from "./schema.js";

const OUTPUT_PATH = join(
  import.meta.dirname,
  "../../packages/oxa-types-ts/src/index.ts"
);

interface SchemaProperty {
  type?: string;
  const?: string;
  description?: string;
  items?: { $ref?: string; type?: string };
  $ref?: string;
  minimum?: number;
  maximum?: number;
  additionalProperties?: boolean;
}

interface SchemaDefinition {
  title: string;
  description?: string;
  type?: string;
  anyOf?: Array<{ $ref: string }>;
  properties?: Record<string, SchemaProperty>;
  required?: string[];
}

export async function generateTs(): Promise<void> {
  const schema = loadMergedSchema();
  const definitions = schema.definitions as Record<string, SchemaDefinition>;

  const lines: string[] = [
    "/**",
    " * TypeScript types generated from the OXA JSON Schema.",
    " *",
    " * Do not edit this file directly. Instead, edit the YAML schema files",
    " * in the schema/ directory and run `pnpm codegen ts`.",
    " */",
    "",
  ];

  // Generate object types first (non-union types)
  for (const [name, def] of Object.entries(definitions)) {
    if (!def.anyOf && def.type === "object") {
      lines.push(...generateInterface(name, def));
      lines.push("");
    }
  }

  // Generate union types
  for (const [name, def] of Object.entries(definitions)) {
    if (def.anyOf) {
      lines.push(...generateUnion(name, def));
      lines.push("");
    }
  }

  const code = lines.join("\n");
  const formatted = await prettier.format(code, {
    parser: "typescript",
    filepath: OUTPUT_PATH,
  });

  writeFileSync(OUTPUT_PATH, formatted);
  console.log(`Generated ${OUTPUT_PATH}`);
}

function generateInterface(name: string, def: SchemaDefinition): string[] {
  const lines: string[] = [];

  // Add JSDoc
  if (def.description) {
    lines.push("/**");
    lines.push(` * ${def.description}`);
    lines.push(" */");
  }

  lines.push(`export interface ${name} {`);

  const required = new Set(def.required || []);

  for (const [propName, prop] of Object.entries(def.properties || {})) {
    // Add property description
    if (prop.description) {
      lines.push(`  /**`);
      lines.push(`   * ${prop.description}`);
      lines.push(`   */`);
    }

    const optional = required.has(propName) ? "" : "?";
    const tsType = getTypeScriptType(prop);
    lines.push(`  ${propName}${optional}: ${tsType};`);
  }

  lines.push("}");
  return lines;
}

function generateUnion(name: string, def: SchemaDefinition): string[] {
  const lines: string[] = [];

  // Add JSDoc
  if (def.description) {
    lines.push("/**");
    lines.push(` * ${def.description}`);
    lines.push(" */");
  }

  const members =
    def.anyOf?.map((item) => {
      const ref = item.$ref;
      const typeName = ref?.replace("#/definitions/", "") || "unknown";
      return typeName;
    }) || [];

  lines.push(`export type ${name} = ${members.join(" | ")};`);
  return lines;
}

function getTypeScriptType(prop: SchemaProperty): string {
  // Handle const values (type discriminator)
  if (prop.const) {
    return `"${prop.const}"`;
  }

  // Handle $ref
  if (prop.$ref) {
    return prop.$ref.replace("#/definitions/", "");
  }

  // Handle arrays
  if (prop.type === "array" && prop.items) {
    if (prop.items.$ref) {
      const itemType = prop.items.$ref.replace("#/definitions/", "");
      return `${itemType}[]`;
    }
    if (prop.items.type === "string") {
      return "string[]";
    }
    return "unknown[]";
  }

  // Handle basic types
  switch (prop.type) {
    case "string":
      return "string";
    case "integer":
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "object":
      if (prop.additionalProperties) {
        return "Record<string, unknown>";
      }
      return "object";
    default:
      return "unknown";
  }
}
