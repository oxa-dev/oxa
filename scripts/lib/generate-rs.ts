/**
 * Generate Rust types from the OXA JSON Schema.
 *
 * This module generates Rust structs and enums with:
 *
 * - monostate MustBe! types for type discriminator fields
 * - Serde derives for JSON serialization/deserialization
 * - Untagged enums for union types (discrimination via MustBe! in each variant)
 * - Full documentation comments from schema descriptions
 * - Proper handling of optional vs required fields
 */

import { execSync } from "child_process";
import { readFileSync, writeFileSync } from "fs";
import { join } from "path";

import { loadMergedSchema } from "./schema.js";
import { getVersion } from "./version.js";

const PACKAGE_DIR = join(import.meta.dirname, "../../packages/oxa-types-rs");

const OUTPUT_PATH = join(PACKAGE_DIR, "src/lib.rs");

const CARGO_TOML_PATH = join(PACKAGE_DIR, "Cargo.toml");

interface SchemaProperty {
  type?: string;
  const?: string;
  description?: string;
  items?: { $ref?: string; type?: string };
  $ref?: string;
  minimum?: number;
  maximum?: number;
  additionalProperties?: boolean;
}

interface SchemaDefinition {
  title: string;
  description?: string;
  type?: string;
  anyOf?: Array<{ $ref: string }>;
  properties?: Record<string, SchemaProperty>;
  required?: string[];
}

export async function generateRs(): Promise<void> {
  // Sync version from root package.json to Cargo.toml
  const version = getVersion();
  const cargoContent = readFileSync(CARGO_TOML_PATH, "utf-8");
  const versionMatch = cargoContent.match(/^version = "(.+)"$/m);
  if (versionMatch && versionMatch[1] !== version) {
    const updatedContent = cargoContent.replace(
      /^version = ".+"$/m,
      `version = "${version}"`,
    );
    writeFileSync(CARGO_TOML_PATH, updatedContent);
    console.log(`Synced version to ${version} in ${CARGO_TOML_PATH}`);
  }

  const schema = loadMergedSchema();
  const definitions = schema.definitions as Record<string, SchemaDefinition>;

  const lines: string[] = [
    "//! Rust types generated from the OXA JSON Schema.",
    "//!",
    "//! Do not edit this file directly. Instead, edit the YAML schema files",
    "//! in the schema/ directory and run `pnpm codegen rs`.",
    "",
    "// We can't derive Eq because serde_json::Value doesn't implement it (floats can be NaN)",
    "#![allow(clippy::derive_partial_eq_without_eq)]",
    "",
    "use monostate::MustBe;",
    "use serde::{Deserialize, Serialize};",
    "",
  ];

  // Generate struct types first (non-union types)
  for (const [name, def] of Object.entries(definitions)) {
    if (!def.anyOf && def.type === "object") {
      lines.push(...generateStruct(name, def));
      lines.push("");
    }
  }

  // Generate enum types for unions
  for (const [name, def] of Object.entries(definitions)) {
    if (def.anyOf) {
      lines.push(...generateEnum(name, def));
      lines.push("");
    }
  }

  const code = lines.join("\n");
  writeFileSync(OUTPUT_PATH, code);

  // Format with rustfmt (skip if not available)
  try {
    execSync(`rustfmt ${OUTPUT_PATH}`, { stdio: "inherit" });
  } catch {
    console.warn("Warning: Could not format with rustfmt (is Rust installed?)");
  }

  console.log(`Generated ${OUTPUT_PATH}`);
}

function generateStruct(name: string, def: SchemaDefinition): string[] {
  const lines: string[] = [];

  // Add doc comment
  if (def.description) {
    lines.push(`/// ${def.description}`);
  }

  lines.push("#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]");
  lines.push(`pub struct ${name} {`);

  const required = new Set(def.required || []);

  for (const [propName, prop] of Object.entries(def.properties || {})) {
    // Add field description
    if (prop.description) {
      lines.push(`    /// ${prop.description}`);
    }

    const rustType = getRustType(prop);
    const isRequired = required.has(propName);

    // Handle the "type" field which is a reserved keyword in Rust
    const fieldName = propName === "type" ? "r#type" : toSnakeCase(propName);

    // Add serde rename if field name differs from JSON
    const jsonName = propName;
    const needsRename = fieldName !== jsonName && fieldName !== `r#${jsonName}`;

    if (isRequired) {
      if (needsRename) {
        lines.push(`    #[serde(rename = "${jsonName}")]`);
      }
      lines.push(`    pub ${fieldName}: ${rustType},`);
    } else {
      // Optional fields use Option<T> with skip_serializing_if
      lines.push(`    #[serde(skip_serializing_if = "Option::is_none")]`);
      if (needsRename) {
        lines.push(`    #[serde(rename = "${jsonName}")]`);
      }
      lines.push(`    pub ${fieldName}: Option<${rustType}>,`);
    }
  }

  lines.push("}");
  return lines;
}

function generateEnum(name: string, def: SchemaDefinition): string[] {
  const lines: string[] = [];

  // Add doc comment
  if (def.description) {
    lines.push(`/// ${def.description}`);
  }

  lines.push("#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]");
  // Use untagged enum - discrimination happens via MustBe! in each variant's type field
  lines.push("#[serde(untagged)]");
  lines.push(`pub enum ${name} {`);

  const members =
    def.anyOf?.map((item) => {
      const ref = item.$ref;
      return ref?.replace("#/definitions/", "") || "Unknown";
    }) || [];

  for (const member of members) {
    lines.push(`    ${member}(${member}),`);
  }

  lines.push("}");

  return lines;
}

function getRustType(prop: SchemaProperty): string {
  // Handle const values (type discriminator) - use MustBe!
  if (prop.const) {
    return `MustBe!("${prop.const}")`;
  }

  // Handle $ref
  if (prop.$ref) {
    const typeName = prop.$ref.replace("#/definitions/", "");
    return typeName;
  }

  // Handle arrays
  if (prop.type === "array" && prop.items) {
    if (prop.items.$ref) {
      const itemType = prop.items.$ref.replace("#/definitions/", "");
      return `Vec<${itemType}>`;
    }
    if (prop.items.type === "string") {
      return "Vec<String>";
    }
    return "Vec<serde_json::Value>";
  }

  // Handle basic types
  switch (prop.type) {
    case "string":
      return "String";
    case "integer":
      return "i64";
    case "number":
      return "f64";
    case "boolean":
      return "bool";
    case "object":
      if (prop.additionalProperties) {
        return "serde_json::Value";
      }
      return "serde_json::Value";
    default:
      return "serde_json::Value";
  }
}

function toSnakeCase(s: string): string {
  return s
    .replace(/([A-Z])/g, "_$1")
    .toLowerCase()
    .replace(/^_/, "");
}
