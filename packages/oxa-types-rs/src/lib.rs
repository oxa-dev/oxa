//! Rust types generated from the OXA JSON Schema.
//!
//! Do not edit this file directly. Instead, edit the YAML schema files
//! in the schema/ directory and run `pnpm codegen rs`.

// We can't derive Eq because serde_json::Value doesn't implement it (floats can be NaN)
#![allow(clippy::derive_partial_eq_without_eq)]

use monostate::MustBe;
use serde::{Deserialize, Serialize};

/// A document with metadata, title, and block content.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Document {
    /// The type discriminator for Document nodes.
    pub r#type: MustBe!("Document"),
    /// A unique identifier for the node.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A list of class names for styling or semantics.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classes: Option<Vec<String>>,
    /// Arbitrary key-value data attached to the node.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<serde_json::Value>,
    /// Arbitrary document metadata.
    pub metadata: serde_json::Value,
    /// The document title as inline content.
    pub title: Vec<Inline>,
    /// The block content of the document.
    pub children: Vec<Block>,
}

/// A heading with a level and inline content.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Heading {
    /// The type discriminator for Heading nodes.
    pub r#type: MustBe!("Heading"),
    /// A unique identifier for the node.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A list of class names for styling or semantics.
    pub classes: Vec<String>,
    /// Arbitrary key-value data attached to the node.
    pub data: serde_json::Value,
    /// The heading level (1-6).
    pub level: i64,
    /// The inline content of the heading.
    pub children: Vec<Inline>,
}

/// A paragraph of inline content.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Paragraph {
    /// The type discriminator for Paragraph nodes.
    pub r#type: MustBe!("Paragraph"),
    /// A unique identifier for the node.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A list of class names for styling or semantics.
    pub classes: Vec<String>,
    /// Arbitrary key-value data attached to the node.
    pub data: serde_json::Value,
    /// The inline content of the paragraph.
    pub children: Vec<Inline>,
}

/// Strongly emphasized content (typically bold).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Strong {
    /// The type discriminator for Strong nodes.
    pub r#type: MustBe!("Strong"),
    /// A unique identifier for the node.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A list of class names for styling or semantics.
    pub classes: Vec<String>,
    /// Arbitrary key-value data attached to the node.
    pub data: serde_json::Value,
    /// The inline content to emphasize.
    pub children: Vec<Inline>,
}

/// A text node containing a string value.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Text {
    /// The type discriminator for Text nodes.
    pub r#type: MustBe!("Text"),
    /// A unique identifier for the node.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A list of class names for styling or semantics.
    pub classes: Vec<String>,
    /// Arbitrary key-value data attached to the node.
    pub data: serde_json::Value,
    /// The text content.
    pub value: String,
}

/// Union of all block content types.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Block {
    Heading(Heading),
    Paragraph(Paragraph),
}

/// Union of all inline content types.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Inline {
    Text(Text),
    Strong(Strong),
}
